https://habr.com/ru/post/173821/ - от сюда
Основным показателем сложности алгоритма является время, необходимое для решения задачи и объём требуемой памяти.

Также при анализе сложности для класса задач определяется некоторое число, характеризующее некоторый объём данных –
размер входа.
Итак, можем сделать вывод, что сложность алгоритма – функция размера входа.
Сложность алгоритма может быть различной при одном и том же размере входа, но различных входных данных.

Существуют понятия сложности в худшем, среднем или лучшем случае. Обычно, оценивают сложность в худшем случае.

https://bimlibik.github.io/posts/complexity-of-algorithms/ - от сюда

Константная - O(1).
Означает, что вычислительная сложность алгоритма не зависит от входных данных.
Однако, это не значит, что алгоритм выполняется за одну операцию или требует очень мало времени.
Это означает, что время не зависит от входных данных.

Линейная - O(n).
Означает, что сложность алгоритма линейно растёт с увеличением входных данных.
Другими словами, удвоение размера входных данных удвоит и необходимое время для выполнения алгоритма.

В функции два последовательных цикла for, каждый из которых проходит массив длиной n,
следовательно сложность будет: O(n + n) = O(n)
Линейная функция, Рекурсивная функция.

Логарифмическая - O(log n).
Означает, что сложность алгоритма растёт логарифмически с увеличением входных данных.
Другими словами это такой алгоритм, где на каждой итерации берётся половина элементов.
К алгоритмам с такой сложностью относятся алгоритмы типа “Разделяй и Властвуй” (Divide and Conquer),
например бинарный поиск.


Линеарифметическая или линеаризованная - O(n * log n).
Означает, что удвоение размера входных данных увеличит время выполнения чуть более, чем вдвое.
Примеры алгоритмов с такой сложностью: Сортировка слиянием или множеством n элементов.

Квадратичная - O(n2), O(n^2).
Означает, что удвоение размера входных данных увеличивает время выполнения в 4 раза.
Например, при увеличении данных в 10 раз, количество операций (и время выполнения) увеличится примерно в 100 раз.
Если алгоритм имеет квадратичную сложность, то это повод пересмотрет
В функции есть цикл в цикле, каждый из них проходит массив длиной n, следовательно сложность будет: O(n * n) = O(n2)

Шпаргалка
Небольшие подсказки, которые помогут определить сложность алгоритма.

Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1).
Перебор коллекции это O(n).
Вложенные циклы по той же коллекции это O(n2).
Разделяй и властвуй (Divide and Conquer) всегда O(log n).
Итерации которые используют “Разделяй и властвуй” (Divide and Conquer) это O(n log n).



